<?php

// $Id$

/**
 *@file
 * Suggests links between pages on your site
 *  
 * before publication, 
 * **error handling http://drupal.org/node/672504
 * **Way to flag as reviewed? Would that even be something you'd want?
 * **body['und'][0]['value'] consistent? what the hell is 'und'?
 * **needs to be more generalized: option to match between content types, fields
 * **move some internal functions to an include file?
 * **comments conform to standards
 * 
 * *Test line from d7dev
 */

/**
 * Implements hook_init()
 */
function ncpedia_linkrecs_init() {

  // Grab the maximum number of link suggestions allowed from a variable, or set default
  $max_suggestions = variable_get('ncpedia_linkrecs_max', 50);
  // Save the max as a variable
  variable_set('ncpedia_linkrecs_max', $max_suggestions);
  
  // Grab the maximum number of link suggestions allowed from a variable, or set default
  $context_length = variable_get('ncpedia_linkrecs_context_length', 60);
  // Save the max as a variable
  variable_set('ncpedia_linkrecs_context_length', $context_length);
}

/**
 * Implements hook_menu().
 */
function ncpedia_linkrecs_menu() {
  $items['admin/config/content/linkrecs'] = array(
    'title' => 'Link suggestions',
    'description' => 'Provides linking recommendations for edited pages.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ncpedia_linkrecs_page'),
    'access arguments' => array('access link suggestions page'),
  );
  $items['admin/config/content/linkrecs/settings'] = array(
    'title' => 'Link recommender settings',
    'description' => 'link recommender configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ncpedia_linkrecs_admin_settings'),
    'access arguments' => array('administer link recommender'),
    'file' => 'ncpedia_linkrecs.admin.inc',
    'file path' => drupal_get_path('module', 'ncpedia_linkrecs'),
  );  
  return $items;
}

/**
 * Implements hook_permission().
 */
function ncpedia_linkrecs_permission() {
  return array(
    'administer link recommender' => array(
      'title' => t('Administer link suggestions module'),
      'description' => t('Perform administration tasks for link suggestions module.'),
    ),
    'access link suggestions page' => array(
      'title' => t('Access Linking Suggestions'),
      'description' => t('See suggested links when editing pages.'),
    ),
  );
}

/**
 * Main form-building page
 */
function ncpedia_linkrecs_page($form, &$form_state) {
  
  $form = array();
  $requested = substr(strrchr(current_path(), "/"), 1);
  
  if ($requested !== 'linkrecs') {
    $list_of_links = '<p>' . t('Suggested links to ');
    $list_of_links .= l(ncpedia_linkrecs_get_title($requested), 'node/'.$requested, array('attributes' => array('target' => '_blank')));
    $list_of_links .= t(" below. Review the suggestions (all links open in a new window) and 
      select which you'd like linked, then click 'Create Links' to update. External links
      are replaced.");
    $list_of_links .= '<em>' . t('You should review all updates once they are completed.') . '</em></p>';
    $titles = ncpedia_linkrecs_check_for_links($requested);
    
    //Extract title variations; used for plural checking
    $title_list = array();
    foreach($titles as $title_variation => $link_candidates) {
      $title_list[] = $title_variation;
    }
      
    if (!empty($titles)) {
      $form['list'] = array(
        '#type' => 'markup',
        '#markup' => $list_of_links,
      );
      $form['checkboxes-toggle'] = array(
        '#title' => t('Check/Uncheck All'), 
        '#type' => 'checkbox',
        '#default_value' => 0,
      );
      foreach($titles as $title_variation => $link_candidates) {
        if (in_array($title_variation . 's', $title_list)) {
          $form['links'][$title_variation] = array(
            '#title' => t('Experimental plural variation (may not make sense): ' . $title_variation),
            '#type' => 'fieldset',
            '#collapsible' => TRUE,
            '#collapsed' => TRUE,
          );
        }
        else {
          $form['links'][$title_variation] = array(
            '#title' => t('Matches for: ' . $title_variation),
            '#type' => 'fieldset',
            '#collapsible' => TRUE,
            '#collapsed' => FALSE,
          );          
        }
        if (isset($link_candidates['skip'])) { 
          $form['links'][$title_variation]['skip'] = array(
            '#type' => 'markup',
            '#markup' => $link_candidates['skip'],
          );
        }
        else {
          foreach($link_candidates as $page) {
            $form['links'][$title_variation][$page['nid']] = array(
              '#title' => $page['link'],
              '#description' => $page['context'],
              '#link_type' => $page['link-type'],
              '#type' => 'checkbox',
              '#default_value' => 0,
              '#states' => array(
                'unchecked' => array (
                  ':input[name="checkboxes-toggle"]' => array('unchecked' => TRUE),
                ),
              )
            );    
          }
        }
      }
      $form['linkrecs-submit'] = array(
        '#type' => 'submit',
        '#value' => t('Create Links'),
      );
    }
    else {
      $options = '<p>' . t('No suggested links found.') . '</p>';
      $options .= '<p>' . l(t('Back to ') . ncpedia_linkrecs_get_title($requested), 'node/'.$requested) . '</p>';
      $form['information'] = array(
        '#type' => 'markup',
        '#markup' => $options,
      );
    }
  }
  else {
    $form['information'] = array(
      '#type' => 'markup',
      '#markup' => 'Edit any page and submit to see link suggestions.',
    );
    $form['manual-input'] = array(
      '#title' => t('Or: enter a node number'),
      '#type' => 'textfield',
      '#size' => 10,
    );
    $form['linkrecs-submit'] = array(
      '#type' => 'submit',
      '#value' => t('Get link suggestions'),
    );
  }
  
  return $form;
}

function ncpedia_linkrecs_page_submit($form, &$form_state) {
 
  //when submitted as a request to view link suggestions
  if ((isset($form['manual-input']['#value']))&&(is_numeric($form['manual-input']['#value']))) {
    $form_state['redirect'] = 'admin/config/content/linkrecs/' . $form['manual-input']['#value'];
  }
  //normal suggestion form submission
  else {
    $link_to_node_id = $form_state['build_info']['args'][0]; 
    foreach ($form_state['complete form']['links'] as $linked_term => $linked_term_array) {
      if (is_array($linked_term_array)) {
        foreach ($linked_term_array as $node_to_update => $match_array) {
          if ((is_array($match_array)) && (isset($match_array['#value'])) && ($match_array['#value'] === 1)) {
            //Get selected entry body from database, update, save
            $n = node_load($node_to_update); 
            $temp_body = ncpedia_linkrecs_update_links($linked_term, $link_to_node_id, $n->body['und'][0]['value'], $match_array['#link_type']);
            if ($temp_body !== '') {
              drupal_set_message($temp_body);
              $n->body['und'][0]['value'] = $temp_body;  
              //node_save($n);
              $report_success = l($n->title, 'node/'. $n->nid, array('attributes' => array('target' => '_blank')));
              $report_success .= t(" updated.");
              drupal_set_message($report_success);
            }
            else {
              drupal_set_message("Sorry, there was an error with the update. No changes were made.");
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_node_update()
 * 
 * Does a basic database scan to see if there are match candidates.
 * If so, provides a link for detailed review.
 */
function ncpedia_linkrecs_node_update($node) {
  
  $max_links_suggested = variable_get('ncpedia_linkrecs_max', 50);
  
  //$title initialized as array of parsed titles - 
  //see ncpedia_linkrecs_parse_title documentation
  $title = ncpedia_linkrecs_parse_title($node->title);
  $no_match_found = TRUE;

  foreach ($title as $nt) {
    if ($no_match_found) {
      //Pull titles of matches for count & approval
      $query = db_select('field_data_body', 'fdb');    
      $query->join('node','n','n.nid = fdb.entity_id');
      $query->fields('n', array('title', 'nid'))
      ->fields('fdb', array('body_value'))
      ->orderBy('title', 'ASC')
      ->condition('fdb.body_value', '%'.db_like($nt).'%', 'LIKE')
      ->addTag('node access');

      $result = $query->execute();
      if ($result->rowCount() <= $max_links_suggested) {
        foreach ($result as $row) {
          
          $existing_link_check = ncpedia_linkrecs_review_links($nt, ncpedia_linkrecs_get_tempbody($row->body_value));
          
          //Proceed with creating a link and contextual text, skipping:
          // * the entry itself (same nid)
          // * articles that don't pass link review
          if (($row->nid !== $node->nid) && (($existing_link_check == 'unlinked') || ($existing_link_check == 'external'))) {
            //If any items are found, present the link for further review, where all suggested links will be
            //available. No need to go beyond a preliminary list for this check, or even continue search 
            //once we've found something.
            $helpful_msg = t("Link suggestions available for "). $node->title . t(". Click to review (opens new window).");
            drupal_set_message(l($helpful_msg, 'admin/config/content/linkrecs/' . $node->nid, array('attributes' => array('target' => '_blank'))));
            $no_match_found = FALSE;
            break;
          }
        }
      }
      else {
        drupal_set_message($result->rowCount() . " link suggestions found for $nt, but ignored. (Number found exceeds maximum of $max_links_suggested.)");
      }
    }
  }
}

/**
 * Returns a node's title when given a node id
 * 
 * @param integer $nid
 * @return string
 */
function ncpedia_linkrecs_get_title($nid) {
  $result = db_query('SELECT n.title FROM {node} n WHERE n.nid = :nid', array(':nid' => $nid));
  $init_title = $result->fetchCol();
  return $init_title[0];
}

/**
 * Takes a string as a full title, returns array of possible titles 
 * 
 * @param type $title
 */
function ncpedia_linkrecs_parse_title($full_title) {
  
  //Running list of strings to ignore, keep as a regex
  $verboten_list = '/north|carolina|tar|heel|junior|historian|research|branch/i';

  //Title strings that should be removed
  $title_removes_list = array (
    ' (from Tar Heel Junior Historian)',
  );
  $title_replacements_list = array (
    '',
  );
  
  $title[] = trim(str_replace($title_removes_list, $title_replacements_list, $full_title));

  //Check for cases of node titles being lastname, firstname(s)
  //if found, rearrange. Keep original in array, though
  if (substr_count($title[0], ',') > 1) {
    $variations = preg_split('/,\s*/i', $title[0]);
    $title[] = $variations[0] . ', ' . $variations[1];
    $title[] = $variations[1] . ' ' . $variations[0];
    $title[] = $variations[1] . ' ' . $variations[0] . ', ' . $variations[2];
  }  
  elseif (substr_count($title[0], ',') === 1) {
    $title[] =  ltrim(strstr($title[0], ','), ', ') . ' ' . strstr($title[0], ',', TRUE);
  }
  else { 
    //inferring it's not a name, do a few other small things:

    //de-pluralize - can't reliably do this but at least try a simple -s removal
    if (preg_match('/s\Z/i', $title[0])) {
      $title[] = substr($title[0], 0, strlen($title[0])-1);
    }  
    //check for multi-part entries, strip "Part:" text if found
    //no need to bother trying to match "Part:" text, original can be overwritten
    if (preg_match('/\s-\sPart\s[1-9]:\s/i', $title[0])) {
      $temp_title = preg_replace('/\s-\sPart\s[1-9]:\s/i', '***', $title[0]);
      $title = explode('***', $temp_title);    
    }
  }
  //Additionally populate array word clusters up to two words
  //don't count clusters where all words are 3 chars or less
  foreach ($title as $t) {
    $all_the_words = str_word_count($t, 1);
    for ($i=count($all_the_words)-1; $i>1; $i--) {
      for ($j=0; $j<=count($all_the_words)-$i; $j++) {
        $str = '';
        $no_short_words = TRUE;
        for ($k=0; $k<$i; $k++) {
          if (strlen($all_the_words[$j+$k]) <= 3) {
            $no_short_words = FALSE;
            break;
          }
          else {
            $str .= $all_the_words[$j+$k] . ' ';          
          }
        }
        //skip anything with short words or common phrases
        $str = rtrim($str);
        if (($no_short_words) && (!preg_match($verboten_list, $str)) && (!in_array($str, $title))) { 
          $title[] = $str;
        }
      }
    }
  }
  return $title;  
}

/**
 * Searches database for title matches
 * 
 * $nid is the node in question's ID
 * 
 * returns link array
 */
function ncpedia_linkrecs_check_for_links($nid) {
  
  $max_links_suggested = variable_get('ncpedia_linkrecs_max', 50);
  $context_string_length = variable_get('ncpedia_linkrecs_context_length', 60);
  
  $title = ncpedia_linkrecs_parse_title(ncpedia_linkrecs_get_title($nid));  
 
  $links = array();
      
  //keep track of all link suggestions to avoid duplication  
  $master_list = array();
 
  foreach ($title as $nt) {
      
    //Pull titles of matches for count & approval
    //Query does not do any complex searching, just looks for matching text
    //We will do more thorough checks below
    $query = db_select('field_data_body', 'fdb');    
    $query->join('node','n','n.nid = fdb.entity_id');
    $query->fields('n', array('title', 'nid'))
    ->fields('fdb', array('body_value'))
    ->orderBy('title', 'ASC')
    ->condition('fdb.body_value', '%'.db_like($nt).'%', 'LIKE')
    ->addTag('node access');
    
    $result = $query->execute();
    
    if ($result->rowCount() <= $max_links_suggested) {
      foreach ($result as $row) {
        //check master list, if not there, add it and proceed
        if (!in_array($row->nid, $master_list)) {
         
          //The query above merely matched text. However, there are instances when the match
          //is not suitable:
          //1. If the matching text is contained within an H1 tag (i.e., it's the title)
          //2. If the matching text is contained within an image's alt/title text
          //3. If the matching text is already linked
          //
          //In cases 1 & 2, we assume there are non-title, non-image date mataches as well,
          //so we'll just strip out the H1 and IMGs and look elsewhere. In case 3, if the text
          //is already INTERNALLY linked (i.e., to another page on the site), we will
          //disregard it as a candidate. Though if the text is EXTERNALLY linked, we can 
          //consider updating the link to the new internal candidate.
          
          //set body value, stripping image and h1 tags from original - we don't want to consider
          //text present in alt/title image attributes, nor titles
          $body = ncpedia_linkrecs_get_tempbody($row->body_value);

          //Pass title & body to link reviewer
          //Per that function documentation, one of three statuses is returned:
          //'unlinked' - the text was found in the body, it is not linked          //
          //'external' - the text was found in the body, linked externally
          //'internal' - the text was found in the body, linked internally
          //'not found' - the text was not found at all in the body (this is possible; it may
          //              be a false positive - the match might have been a title or img match
          //              and has been stripped out)
          //
          //We will proceed if unlinked or external
          $existing_link_check = ncpedia_linkrecs_review_links($nt, $body);
          
          //Proceed with creating a link and contextual text, skipping:
          // * the entry itself (same nid)
          // * articles that already have a matching internal link
          if (($row->nid !== $nid) && (($existing_link_check == 'unlinked') || ($existing_link_check == 'external'))) {

            $master_list[] = $row->nid;
            
            //Find the first match. This is generally the only link we'd add.
            $location = stripos($body, $nt);
            //Context snippet start point should be the location of the needle minus the 
            //context length value. Exception is when needle appears very close to the 
            //beginning of the haystack, in which case, just
            //start the snippet at the beginning of the haystack.
            $start_context = $location > $context_string_length ? $location - $context_string_length : 0;
            //Total context snippet length should be twice the defined length value, plus 
            //the length of the needle. Alter this if the needle appears to close to the 
            //end of the haystack. In that case, truncate
            //the snippet to end at the end of the haystack.
            $context_length = $location + strlen($nt) + $context_string_length < strlen($body) ? 
              strlen($nt)+$context_string_length*2 : strlen($body) - $start_context;

            //Set context snippet and append ellipses or appropriate notice
            $context = strip_tags(substr($body, $start_context, $context_length));
            $context = $start_context !== 0 ? '...' . $context : '[START OF BODY]' . $context;
            $context = $context_length > $context_string_length * 2 ? $context . '...' : $context . '[END OF BODY]';   

            $links[$nt][$row->title]['nid'] = $row->nid;
            $links[$nt][$row->title]['link'] = l($row->title, "node/" . $row->nid, array('attributes' => array('target' => '_blank')));
            $links[$nt][$row->title]['context'] = $existing_link_check === 'external' ?
                    'EXTERNAL LINK FOUND. UPDATING WILL REPLACE: ' . $context : $context;
            $links[$nt][$row->title]['link-type'] = $existing_link_check;
          }
        }
      }
    }
    else {
      $links[$nt]['skip'] = '<strong>' . t("Skipped. ") . $result->rowCount() . t(" link suggestions found for $nt, exceeding maximum of ") . $max_links_suggested . '</strong>';
    }
  }

  return $links;
}

/**
 * Finds matching text in a node body and determines its link status. Returns one of
 * the following statuses:
 * 
 *'unlinked' - the text was found in the body, it is not linked
 *'external' - the text was found in the body, linked externally
 *'internal' - the text was found in the body, linked internally
 *'not found' - the text was not found at all in the body (this is possible; it may
 *              be a false positive - the match might have been a title or img match
 *              and has been stripped out)
 * 
 * @param string $nt is the 'node title', a string of text to search for
 * @param string $body
 * @return string
 */
function ncpedia_linkrecs_review_links($nt, $body) {

  $status = '';
  
  //Review all the links in the body for the intended match
  //matches[0] = all link tags
  //matches[1] = URL for each tag
  //matches[2] = linked text
  if (preg_match_all('/\<a\shref=\"(.+?)\"\>(.+?)\<\/a\>/is', $body, $matches)) {
    for ($i=0; $i<count($matches[0]); $i++) {
      //check all linked text for a match
      if (stripos($matches[2][$i], $nt) !== FALSE) {  
        //if you find it, assume URL that starts with a / is internal
        if (preg_match('/^\//is', $matches[1][$i])) { 
          $status = 'internal';
          break;
        }
        else {
          $status = 'external';
          break;
        }
      }
    }
  }
  if ($status === '') {
    $status = stripos($body, $nt) !== FALSE ? 'unlinked' : 'not found';
  }
    
  return $status;
}

/**
 * 
 * @param string $nt The title string
 * @param string $update_path The node ID to link to
 * @param string $body
 * @param string $link_type 'external' or 'unlinked' considered; assumed 'unlinked' unless specified
 * @return type
 */
function ncpedia_linkrecs_update_links ($nt, $update_path, $body, $link_type) {

  //Get all the images, store temporarily in $img_matches[0]
  $img_count = preg_match_all('/\<img.+?\/\>/is', $body, $img_matches);
  $h1_count = preg_match_all('/\<h1\>.+?\<?\/h1\>/is', $body, $h1_matches);
  $temp_body = ncpedia_linkrecs_get_tempbody($body);
  
  $updated_body = '';
  
  if ($link_type === 'external') {
    if (preg_match_all('/\<a\shref=\"(.+?)\"\>(.+?)\<\/a\>/is', $temp_body, $matches)) {
      for ($i=0; $i<count($matches[0]); $i++) {
        if (stripos($matches[2][$i],$nt)!==FALSE) {
          $updated_body = str_replace($matches[0][$i], '<a href="/node/' . $update_path . '">' . $matches[2][$i] . '</a>', $temp_body);
          break;
        }
      }
    }
  }
  else {
    //preg_replace used so I can limit to one replacement only
    $updated_body = preg_replace('/(' . $nt . ')/i', '<a href="/node/'. $update_path .'">$1</a>', $temp_body, 1);
  }
  
  //Replace images
  for ($i=0; $i<$img_count; $i++) {
    $updated_body = preg_replace('/!!!IMG_REMOVED!!!/', $img_matches[0][$i], $updated_body, 1);
  }  
  for ($i=0; $i<$h1_count; $i++) {
    $updated_body = preg_replace('/!!!H1_REMOVED!!!/', $h1_matches[0][$i], $updated_body, 1);
  }  
  
  return $updated_body;
}

function ncpedia_linkrecs_get_tempbody($body) {
  
  $search_array = array (
    '/\<img.+?\/\>/is',
    '/\<h1\>.+?\<?\/h1\>/is',
  );
  $replace_array = array (
    '!!!IMG_REMOVED!!!',
    '!!!H1_REMOVED!!!',
  );
  
  return preg_replace($search_array, $replace_array, $body);
}